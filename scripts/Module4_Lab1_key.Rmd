---
title: "Tortoise Occupancy"
author: "Ellen Bledsoe"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Desert Tortoise Occupancy

Analyze survey data for desert tortoises from Saguaro National Park

## Set-Up

I have installed the `unmarked` package for you already in RStudio Cloud. This is a new package we will be using to do our occupancy calculations.

We will need to first load the `tidyverse` and `unmarked` packages.

```{r}
library(tidyverse)
library(unmarked) 
```

Now we need to read in our data set, called `tortoise_occupancy.csv`

```{r}
tort_occ <- read_csv("../data_raw/tortoise_occupancy.csv")
```

#### Explore the data

First, let's take a look at `tort_occ`, our tortoise occupancy data. What does each column represent? How about each row?

```{r}
head(tort_occ)
```

## Naive Occupancy

Before we run any occupancy models that take detection probability into account, let's calculate the naive occupancy.

Naive occupancy is calculated by the number of sites where a species was detected at least once divided by the total number of sites surveyed.

```{r}
naive_detection <- tort_occ %>% 
  mutate(detection = rowSums(.)) %>% 
  summarise(n = n(),
            n_detect = sum(detection > 0)) %>% 
  mutate(naive_det = n_detect/n)
```

Is this estimate of detection going to be higher or lower than when we take detection probability into account?

## Occupancy Models

Now we are going to run a few models that take detection probability into account in our estimate. To do this, we will use the `unmarked` package, which has functions specifically for running these types of models.

To run correctly, the `unmarked` package requires we put our data in a very specific format.

### Prepare Our Data

#### Create a time data frame

First, we need to create a list of data frames (why, I don't know...) that includes our survey occasions.

```{r}
# create the data frame with 20 rows and each column with the survey number
survey_time <- tibble(.rows = 20,
                      time_1 = "1",
                      time_2 = "2",
                      time_3 = "3",
                      time_4 = "4",
                      time_5 = "5")

# make this into a list of one dataframe
survey_time <- list(time = survey_time)
```

#### Create `unmarked` data frame

Now that we have both our occupancy data frame (the encounter histories) and a list that contains our survey data frame, we can create the specific type of data frame that the `unmarked` package requires. To do this, we use the `unmarkedFrameOccu()` function.

Running this line of code will produce a warning, but you can ignore it.

```{r}
tortUMF <- unmarkedFrameOccu(tort_occ, obsCovs = survey_time)
```

Let's take a look at this new data frame that we just created.

```{r}
head(tortUMF) 
```

### Fit Models for Occupancy

The function to run the occupancy model in `unmarked` is `occu()`. It takes the data from our encounter histories and estimates detection probability. It then uses that detection probability estimate to produce an estimate of occupancy.

The function always take the argument for detection probability first and then the argument for occupancy.

Let's demonstrate. Our first model will have detection probability consistent across time (surveys) and occupancy consistent across sites. Remember, an assumption we have about occupancy is that it stays consistent through our surveys

```{r}
# Model p(.)psi(.) -- psi constant across sites, det prob constant over time
pdot_psidot  <- occu(~1 ~1, data = tortUMF)
```

Our second model will have occupancy consistent across sites but detection variability can vary with time (survey occasion).

```{r}
# Model p(t)psi(.) -- psi constant across sites, det prob varies with time (survey occasion)
ptime_psidot <- occu(~time-1 ~1, data = tortUMF)
```

### Model Selection

We can run both models and then use AIC (an index of model quality) to determine which model fits our data the best.

We first make an object with a list of our models. Then we have the function `modSel` run the models and present us with the AIC values.

```{r}
# Assemble models into a list to compare their AIC values
models <- fitList(pdot_psidot  = pdot_psidot, 
                  ptime_psidot = ptime_psidot)
modSel(models)
```

Based on the AIC values, which is our top model?

### Estimates & 95% Confidence Intervals

Now that we have chosen our top model, we want to discover what the actual values detection probability (p) and occupancy (psi) are and our uncertainty around them (95% confidence intervals).

Thankfully, there are functions that produce these values for us.

First, let's look at the parameter estimates (p and psi)

```{r}
# This pulls out the coefficients (estimates) for the model

# For model: p(.)psi(.)
plogis(coef(pdot_psidot))  # estimates of psi and p

# For model:  p(t)psi(.)
plogis(coef(ptime_psidot))
```

Note that there are 5 estimates for detection probability in the model that we allowed to vary through time. This is because the model produced a detection probability estimate for each survey occasion rather than just one overall detection probability estimate.

We can also calculate the 95% confidence intervals for each estimate. This time we use the `confint` function. We need to indicate the estimate type:

-   detection probability: `type = "det"`
-   occupancy: `type = "state"`

```{r}
# model p(.)psi(.)
plogis(confint(pdot_psidot, type = "det",   level = 0.95)) # 95% CI for p
plogis(confint(pdot_psidot, type = "state", level = 0.95)) # 95% CI for psi

# model p(t)psi(.)
plogis(confint(ptime_psidot, type = "det",   level = 0.95))
plogis(confint(ptime_psidot, type = "state", level = 0.95))
```

Similarly to the parameter estimates, we have 5 sets of confidence intervals for the model that allows the estimates of detection probability to vary with time; these are the confidence intervals for each estimate.
